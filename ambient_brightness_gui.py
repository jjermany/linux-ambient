#!/usr/bin/env python3
"""
GUI Settings Manager for Ambient Brightness Control
Provides graphical interface for configuration and monitoring
"""

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, Gdk, GLib, AppIndicator3

import os
import sys
import json
import socket
import subprocess
import signal
import time
from pathlib import Path
from typing import Optional, Dict

CONFIG_DIR = Path.home() / '.config' / 'ambient-brightness'
CONFIG_FILE = CONFIG_DIR / 'config.conf'
SOCKET_PATH = '/tmp/ambient-brightness.sock'
GUI_CONFIG_DIR = Path.home() / '.config' / 'ambient-brightness'
GUI_CONFIG_FILE = GUI_CONFIG_DIR / 'gui.conf'
PID_FILE = Path.home() / '.config' / 'ambient-brightness' / 'service.pid'
LOG_FILE = Path.home() / '.config' / 'ambient-brightness' / 'service.log'


class ConfigManager:
    """Manages configuration file reading/writing"""

    @staticmethod
    def load_gui_config() -> Dict:
        """Load GUI-specific configuration"""
        config = {
            'show_system_tray': False,
        }

        if not GUI_CONFIG_FILE.exists():
            return config

        try:
            for line in GUI_CONFIG_FILE.read_text().splitlines():
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()

                    if key in ['show_system_tray']:
                        config[key] = value.lower() in ['true', '1', 'yes']
        except Exception as e:
            print(f"Error loading GUI config: {e}")

        return config

    @staticmethod
    def save_gui_config(config: Dict) -> bool:
        """Save GUI-specific configuration"""
        try:
            # Ensure config directory exists
            GUI_CONFIG_DIR.mkdir(parents=True, exist_ok=True)

            # Generate config content
            content = "# Ambient Brightness GUI Configuration\n\n"
            for key, value in config.items():
                if isinstance(value, bool):
                    content += f"{key}={'true' if value else 'false'}\n"
                else:
                    content += f"{key}={value}\n"

            GUI_CONFIG_FILE.write_text(content)
            return True

        except Exception as e:
            print(f"Error saving GUI config: {e}")
            return False

    @staticmethod
    def load_config() -> Dict:
        """Load configuration from file"""
        config = {
            'enable_camera': True,
            'smoothing_factor': 0.3,
            'update_interval': 2.0,
            'min_brightness': 10,
            'max_brightness': 100,
        }

        if not Path(CONFIG_FILE).exists():
            return config

        try:
            for line in Path(CONFIG_FILE).read_text().splitlines():
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()

                    if key in ['enable_camera']:
                        config[key] = value.lower() in ['true', '1', 'yes']
                    elif key in ['smoothing_factor', 'update_interval']:
                        config[key] = float(value)
                    elif key in ['min_brightness', 'max_brightness']:
                        config[key] = int(value)
        except Exception as e:
            print(f"Error loading config: {e}")

        return config

    @staticmethod
    def save_config(config: Dict) -> bool:
        """Save configuration to file"""
        try:
            # Ensure config directory exists
            config_path = Path(CONFIG_FILE)
            config_path.parent.mkdir(parents=True, exist_ok=True)

            # Generate config content
            content = "# Ambient Brightness Control Configuration\n"
            content += "# Generated by GUI Settings Manager\n\n"

            for key, value in config.items():
                if isinstance(value, bool):
                    content += f"{key}={'true' if value else 'false'}\n"
                else:
                    content += f"{key}={value}\n"

            # Write config file (no root needed!)
            config_path.write_text(content)
            return True

        except Exception as e:
            print(f"Error saving config: {e}")
            return False


class ServiceControl:
    """Control systemd service or standalone process"""

    def __init__(self):
        self.use_systemd = self._check_systemd_available()
        self.script_path = Path.home() / '.local' / 'bin' / 'ambient_brightness.py'

    @staticmethod
    def _check_systemd_available() -> bool:
        """Check if systemd is available and working"""
        try:
            # Use 'list-units' instead of 'is-system-running' because the latter
            # can fail even when systemd is functional (e.g., in degraded state)
            result = subprocess.run(
                ['systemctl', '--user', 'list-units'],
                capture_output=True,
                text=True,
                timeout=2
            )
            # If we can list units, systemd is available
            return result.returncode == 0
        except:
            return False

    def _read_pid(self) -> Optional[int]:
        """Read PID from file"""
        try:
            if PID_FILE.exists():
                pid = int(PID_FILE.read_text().strip())
                # Check if process is actually running
                try:
                    os.kill(pid, 0)  # Signal 0 just checks if process exists
                    return pid
                except OSError:
                    # Process not running, clean up stale PID file
                    PID_FILE.unlink()
                    return None
            return None
        except:
            return None

    def _write_pid(self, pid: int):
        """Write PID to file"""
        try:
            PID_FILE.parent.mkdir(parents=True, exist_ok=True)
            PID_FILE.write_text(str(pid))
        except Exception as e:
            print(f"Error writing PID file: {e}")

    def _remove_pid(self):
        """Remove PID file"""
        try:
            if PID_FILE.exists():
                PID_FILE.unlink()
        except:
            pass

    def is_running(self) -> bool:
        """Check if service is running"""
        if self.use_systemd:
            try:
                result = subprocess.run(
                    ['systemctl', '--user', 'is-active', 'ambient-brightness'],
                    capture_output=True,
                    text=True,
                    timeout=2
                )
                return result.returncode == 0
            except:
                return False
        else:
            # Check standalone process
            return self._read_pid() is not None

    def is_enabled(self) -> bool:
        """Check if service is enabled"""
        if self.use_systemd:
            try:
                result = subprocess.run(
                    ['systemctl', '--user', 'is-enabled', 'ambient-brightness'],
                    capture_output=True,
                    text=True,
                    timeout=2
                )
                return result.returncode == 0
            except:
                return False
        else:
            # For standalone, check if autostart file exists
            autostart_file = Path.home() / '.config' / 'autostart' / 'ambient-brightness-service.desktop'
            return autostart_file.exists()

    def start(self) -> bool:
        """Start the service"""
        if self.use_systemd:
            try:
                subprocess.run(['systemctl', '--user', 'start', 'ambient-brightness'],
                             check=True, timeout=5)
                return True
            except:
                return False
        else:
            # Start standalone process
            if self.is_running():
                return True  # Already running

            try:
                # Ensure log directory exists
                LOG_FILE.parent.mkdir(parents=True, exist_ok=True)

                # Start the service in background
                with open(LOG_FILE, 'a') as log:
                    process = subprocess.Popen(
                        [sys.executable, str(self.script_path)],
                        stdout=log,
                        stderr=log,
                        start_new_session=True  # Detach from parent
                    )

                    # Write PID file
                    self._write_pid(process.pid)

                    # Wait a bit to see if it starts successfully
                    time.sleep(0.5)

                    # Check if still running
                    if self.is_running():
                        return True
                    else:
                        self._remove_pid()
                        return False
            except Exception as e:
                print(f"Error starting service: {e}")
                return False

    def stop(self) -> bool:
        """Stop the service"""
        if self.use_systemd:
            try:
                subprocess.run(['systemctl', '--user', 'stop', 'ambient-brightness'],
                             check=True, timeout=5)
                return True
            except:
                return False
        else:
            # Stop standalone process
            pid = self._read_pid()
            if pid is None:
                return True  # Not running

            try:
                # Send SIGTERM to gracefully stop
                os.kill(pid, signal.SIGTERM)

                # Wait for process to exit (up to 5 seconds)
                for _ in range(50):
                    try:
                        os.kill(pid, 0)
                        time.sleep(0.1)
                    except OSError:
                        # Process has exited
                        break
                else:
                    # Force kill if still running
                    try:
                        os.kill(pid, signal.SIGKILL)
                    except OSError:
                        pass

                self._remove_pid()
                return True
            except Exception as e:
                print(f"Error stopping service: {e}")
                return False

    def restart(self) -> bool:
        """Restart the service"""
        if self.use_systemd:
            try:
                subprocess.run(['systemctl', '--user', 'restart', 'ambient-brightness'],
                             check=True, timeout=5)
                return True
            except:
                return False
        else:
            # Stop and start
            self.stop()
            time.sleep(0.5)
            return self.start()

    def reload(self) -> bool:
        """Reload service configuration without restarting"""
        if self.use_systemd:
            try:
                # Get PID from systemctl
                result = subprocess.run(
                    ['systemctl', '--user', 'show', '--property=MainPID', 'ambient-brightness'],
                    capture_output=True,
                    text=True,
                    timeout=2
                )
                if result.returncode == 0:
                    pid_line = result.stdout.strip()
                    if '=' in pid_line:
                        pid = int(pid_line.split('=')[1])
                        if pid > 0:
                            os.kill(pid, signal.SIGHUP)
                            return True
                return False
            except Exception as e:
                print(f"Error reloading service: {e}")
                return False
        else:
            # Reload standalone process
            pid = self._read_pid()
            if pid is None:
                return False  # Not running

            try:
                os.kill(pid, signal.SIGHUP)
                return True
            except Exception as e:
                print(f"Error reloading service: {e}")
                return False

    def enable(self) -> bool:
        """Enable service at boot"""
        if self.use_systemd:
            try:
                subprocess.run(['systemctl', '--user', 'enable', 'ambient-brightness'],
                             check=True, timeout=5)
                return True
            except:
                return False
        else:
            # Create autostart desktop entry
            try:
                autostart_dir = Path.home() / '.config' / 'autostart'
                autostart_dir.mkdir(parents=True, exist_ok=True)

                autostart_file = autostart_dir / 'ambient-brightness-service.desktop'
                content = f"""[Desktop Entry]
Type=Application
Name=Ambient Brightness Service
Exec={sys.executable} {self.script_path}
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
"""
                autostart_file.write_text(content)
                return True
            except Exception as e:
                print(f"Error enabling autostart: {e}")
                return False

    def disable(self) -> bool:
        """Disable service at boot"""
        if self.use_systemd:
            try:
                subprocess.run(['systemctl', '--user', 'disable', 'ambient-brightness'],
                             check=True, timeout=5)
                return True
            except:
                return False
        else:
            # Remove autostart desktop entry
            try:
                autostart_file = Path.home() / '.config' / 'autostart' / 'ambient-brightness-service.desktop'
                if autostart_file.exists():
                    autostart_file.unlink()
                return True
            except Exception as e:
                print(f"Error disabling autostart: {e}")
                return False


class StatusMonitor:
    """Monitor service status and sensor readings"""

    def __init__(self, service_control):
        self.light_level = 0
        self.brightness = 0
        self.sensor_type = "Unknown"
        self.service_control = service_control

    def _get_logs(self) -> str:
        """Get service logs from systemd or log file"""
        if self.service_control.use_systemd:
            try:
                result = subprocess.run(
                    ['journalctl', '--user', '-u', 'ambient-brightness', '-n', '50', '--no-pager'],
                    capture_output=True,
                    text=True,
                    timeout=2
                )
                return result.stdout
            except:
                return ""
        else:
            # Read from log file
            try:
                if LOG_FILE.exists():
                    lines = LOG_FILE.read_text().splitlines()
                    return '\n'.join(lines[-50:])  # Last 50 lines
                return ""
            except:
                return ""

    def get_sensor_info(self) -> tuple:
        """Get current sensor information from service logs"""
        try:
            logs = self._get_logs()

            # Parse logs for sensor info
            for line in logs.splitlines():
                if 'Using ALS:' in line:
                    self.sensor_type = "Ambient Light Sensor"
                elif 'Using camera' in line or 'Camera sensor initialized' in line:
                    self.sensor_type = "Camera"
                elif 'Light:' in line and '->' in line:
                    # Parse: "Light: 45.2% -> Brightness: 67%"
                    parts = line.split('Light:')[1].split('->')
                    if len(parts) == 2:
                        light = parts[0].strip().rstrip('%')
                        bright = parts[1].split(':')[1].strip().rstrip('%')
                        try:
                            self.light_level = float(light)
                            self.brightness = int(bright)
                        except:
                            pass

            return (self.light_level, self.brightness, self.sensor_type)

        except:
            return (0, 0, "Unknown")

    def get_backlight_info(self) -> Optional[tuple]:
        """Get current backlight brightness directly"""
        try:
            backlight_base = Path('/sys/class/backlight')
            devices = list(backlight_base.glob('*'))
            if devices:
                device = devices[0]
                max_brightness = int((device / 'max_brightness').read_text().strip())
                current = int((device / 'brightness').read_text().strip())
                percentage = int((current / max_brightness) * 100)
                return (percentage, device.name)
        except:
            pass
        return None


class SettingsWindow(Gtk.Window):
    """Main settings window"""

    def __init__(self):
        super().__init__(title="Ambient Brightness Settings")
        self.set_default_size(600, 500)
        self.set_border_width(10)

        # Load current config
        self.config = ConfigManager.load_config()
        self.gui_config = ConfigManager.load_gui_config()
        self.service_control = ServiceControl()
        self.status_monitor = StatusMonitor(self.service_control)

        # Build UI
        self.build_ui()

        # Start status update timer
        GLib.timeout_add_seconds(2, self.update_status)
        self.update_status()

    def build_ui(self):
        """Build the user interface"""
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(main_box)

        # Header
        header = Gtk.Label()
        header.set_markup("<b><big>Ambient Brightness Control</big></b>")
        main_box.pack_start(header, False, False, 0)

        # Notebook for tabs
        notebook = Gtk.Notebook()
        main_box.pack_start(notebook, True, True, 0)

        # Status Tab
        notebook.append_page(self.create_status_tab(), Gtk.Label(label="Status"))

        # Settings Tab
        notebook.append_page(self.create_settings_tab(), Gtk.Label(label="Settings"))

        # Service Tab
        notebook.append_page(self.create_service_tab(), Gtk.Label(label="Service"))

        # Button box at bottom
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        main_box.pack_start(button_box, False, False, 0)

        # Save button
        save_btn = Gtk.Button(label="Save Settings")
        save_btn.connect("clicked", self.on_save_clicked)
        button_box.pack_end(save_btn, False, False, 0)

        # Close button
        close_btn = Gtk.Button(label="Close")
        close_btn.connect("clicked", lambda w: self.destroy())
        button_box.pack_end(close_btn, False, False, 0)

    def create_status_tab(self):
        """Create status monitoring tab"""
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_border_width(10)

        # Service status
        status_frame = Gtk.Frame(label="Service Status")
        status_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        status_box.set_border_width(10)
        status_frame.add(status_box)
        box.pack_start(status_frame, False, False, 0)

        self.service_status_label = Gtk.Label()
        status_box.pack_start(self.service_status_label, False, False, 0)

        # Current readings
        readings_frame = Gtk.Frame(label="Current Readings")
        readings_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        readings_box.set_border_width(10)
        readings_frame.add(readings_box)
        box.pack_start(readings_frame, False, False, 0)

        # Sensor type
        self.sensor_label = Gtk.Label()
        readings_box.pack_start(self.sensor_label, False, False, 0)

        # Light level
        light_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        readings_box.pack_start(light_box, False, False, 0)
        light_box.pack_start(Gtk.Label(label="Ambient Light:"), False, False, 0)
        self.light_level_bar = Gtk.ProgressBar()
        self.light_level_bar.set_show_text(True)
        light_box.pack_start(self.light_level_bar, True, True, 0)

        # Brightness level
        brightness_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        readings_box.pack_start(brightness_box, False, False, 0)
        brightness_box.pack_start(Gtk.Label(label="Screen Brightness:"), False, False, 0)
        self.brightness_bar = Gtk.ProgressBar()
        self.brightness_bar.set_show_text(True)
        brightness_box.pack_start(self.brightness_bar, True, True, 0)

        # Hardware info
        hw_frame = Gtk.Frame(label="Hardware Information")
        hw_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        hw_box.set_border_width(10)
        hw_frame.add(hw_box)
        box.pack_start(hw_frame, False, False, 0)

        self.hardware_label = Gtk.Label()
        self.hardware_label.set_line_wrap(True)
        self.hardware_label.set_xalign(0)
        hw_box.pack_start(self.hardware_label, False, False, 0)

        return box

    def create_settings_tab(self):
        """Create settings configuration tab"""
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_border_width(10)

        # GUI settings
        gui_frame = Gtk.Frame(label="GUI Settings")
        gui_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        gui_box.set_border_width(10)
        gui_frame.add(gui_box)
        box.pack_start(gui_frame, False, False, 0)

        self.tray_check = Gtk.CheckButton(label="Show system tray icon")
        self.tray_check.set_active(self.gui_config['show_system_tray'])
        gui_box.pack_start(self.tray_check, False, False, 0)

        tray_hint = Gtk.Label()
        tray_hint.set_markup("<small>System tray provides quick access to controls</small>")
        tray_hint.set_xalign(0)
        gui_box.pack_start(tray_hint, False, False, 0)

        # Sensor settings
        sensor_frame = Gtk.Frame(label="Sensor Settings")
        sensor_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        sensor_box.set_border_width(10)
        sensor_frame.add(sensor_box)
        box.pack_start(sensor_frame, False, False, 0)

        self.camera_check = Gtk.CheckButton(label="Enable camera as fallback sensor")
        self.camera_check.set_active(self.config['enable_camera'])
        sensor_box.pack_start(self.camera_check, False, False, 0)

        # Behavior settings
        behavior_frame = Gtk.Frame(label="Behavior Settings")
        behavior_grid = Gtk.Grid()
        behavior_grid.set_border_width(10)
        behavior_grid.set_column_spacing(10)
        behavior_grid.set_row_spacing(10)
        behavior_frame.add(behavior_grid)
        box.pack_start(behavior_frame, False, False, 0)

        # Smoothing factor
        row = 0
        behavior_grid.attach(Gtk.Label(label="Smoothing Factor:", xalign=0), 0, row, 1, 1)
        self.smoothing_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0.1, 1.0, 0.05)
        self.smoothing_scale.set_value(self.config['smoothing_factor'])
        self.smoothing_scale.set_value_pos(Gtk.PositionType.RIGHT)
        self.smoothing_scale.set_digits(2)
        self.smoothing_scale.set_hexpand(True)
        behavior_grid.attach(self.smoothing_scale, 1, row, 1, 1)

        row += 1
        smoothing_hint = Gtk.Label()
        smoothing_hint.set_markup("<small>Higher = faster response, Lower = smoother transitions</small>")
        smoothing_hint.set_xalign(0)
        behavior_grid.attach(smoothing_hint, 0, row, 2, 1)

        # Update interval
        row += 1
        behavior_grid.attach(Gtk.Label(label="Update Interval (seconds):", xalign=0), 0, row, 1, 1)
        self.interval_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 0.5, 5.0, 0.5)
        self.interval_scale.set_value(self.config['update_interval'])
        self.interval_scale.set_value_pos(Gtk.PositionType.RIGHT)
        self.interval_scale.set_digits(1)
        self.interval_scale.set_hexpand(True)
        behavior_grid.attach(self.interval_scale, 1, row, 1, 1)

        # Brightness limits
        limits_frame = Gtk.Frame(label="Brightness Limits")
        limits_grid = Gtk.Grid()
        limits_grid.set_border_width(10)
        limits_grid.set_column_spacing(10)
        limits_grid.set_row_spacing(10)
        limits_frame.add(limits_grid)
        box.pack_start(limits_frame, False, False, 0)

        # Minimum brightness
        row = 0
        limits_grid.attach(Gtk.Label(label="Minimum Brightness (%):", xalign=0), 0, row, 1, 1)
        self.min_brightness_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 1, 50, 1)
        self.min_brightness_scale.set_value(self.config['min_brightness'])
        self.min_brightness_scale.set_value_pos(Gtk.PositionType.RIGHT)
        self.min_brightness_scale.set_digits(0)
        self.min_brightness_scale.set_hexpand(True)
        limits_grid.attach(self.min_brightness_scale, 1, row, 1, 1)

        # Maximum brightness
        row += 1
        limits_grid.attach(Gtk.Label(label="Maximum Brightness (%):", xalign=0), 0, row, 1, 1)
        self.max_brightness_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 50, 100, 1)
        self.max_brightness_scale.set_value(self.config['max_brightness'])
        self.max_brightness_scale.set_value_pos(Gtk.PositionType.RIGHT)
        self.max_brightness_scale.set_digits(0)
        self.max_brightness_scale.set_hexpand(True)
        limits_grid.attach(self.max_brightness_scale, 1, row, 1, 1)

        return box

    def create_service_tab(self):
        """Create service control tab"""
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_border_width(10)

        # Service control
        control_frame = Gtk.Frame(label="Service Control")
        control_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        control_box.set_border_width(10)
        control_frame.add(control_box)
        box.pack_start(control_frame, False, False, 0)

        # Status display
        self.service_control_status = Gtk.Label()
        control_box.pack_start(self.service_control_status, False, False, 0)

        # Buttons
        button_grid = Gtk.Grid()
        button_grid.set_column_spacing(5)
        button_grid.set_row_spacing(5)
        control_box.pack_start(button_grid, False, False, 5)

        # Start/Stop buttons
        self.start_btn = Gtk.Button(label="Start Service")
        self.start_btn.connect("clicked", self.on_start_clicked)
        button_grid.attach(self.start_btn, 0, 0, 1, 1)

        self.stop_btn = Gtk.Button(label="Stop Service")
        self.stop_btn.connect("clicked", self.on_stop_clicked)
        button_grid.attach(self.stop_btn, 1, 0, 1, 1)

        restart_btn = Gtk.Button(label="Restart Service")
        restart_btn.connect("clicked", self.on_restart_clicked)
        button_grid.attach(restart_btn, 0, 1, 2, 1)

        # Enable at boot
        self.enable_check = Gtk.CheckButton(label="Start automatically at boot")
        self.enable_check.set_active(self.service_control.is_enabled())
        self.enable_check.connect("toggled", self.on_enable_toggled)
        control_box.pack_start(self.enable_check, False, False, 5)

        # Logs
        logs_frame = Gtk.Frame(label="Recent Logs")
        logs_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        logs_box.set_border_width(10)
        logs_frame.add(logs_box)
        box.pack_start(logs_frame, True, True, 0)

        # Log text view
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_hexpand(True)
        scrolled.set_vexpand(True)
        logs_box.pack_start(scrolled, True, True, 0)

        self.log_textview = Gtk.TextView()
        self.log_textview.set_editable(False)
        self.log_textview.set_monospace(True)
        scrolled.add(self.log_textview)

        # Refresh logs button
        refresh_btn = Gtk.Button(label="Refresh Logs")
        refresh_btn.connect("clicked", self.on_refresh_logs_clicked)
        logs_box.pack_start(refresh_btn, False, False, 0)

        return box

    def update_status(self):
        """Update status displays"""
        # Service status
        is_running = self.service_control.is_running()
        is_enabled = self.service_control.is_enabled()

        if is_running:
            status_text = "Service is <b>running</b>"
            status_color = "green"
        else:
            status_text = "Service is <b>stopped</b>"
            status_color = "red"

        if is_enabled:
            status_text += " and <b>enabled</b> at boot"
        else:
            status_text += " and <b>disabled</b> at boot"

        # Add mode indicator
        mode = "systemd" if self.service_control.use_systemd else "standalone"
        status_text += f"\n<small>(Mode: {mode})</small>"

        self.service_status_label.set_markup(f'<span color="{status_color}">{status_text}</span>')
        self.service_control_status.set_markup(f'<span color="{status_color}">{status_text}</span>')

        # Update button states
        self.start_btn.set_sensitive(not is_running)
        self.stop_btn.set_sensitive(is_running)
        self.enable_check.set_active(is_enabled)

        # Get sensor readings
        if is_running:
            light, brightness, sensor = self.status_monitor.get_sensor_info()

            self.sensor_label.set_markup(f"<b>Sensor Type:</b> {sensor}")
            self.light_level_bar.set_fraction(light / 100.0)
            self.light_level_bar.set_text(f"{light:.1f}%")
            self.brightness_bar.set_fraction(brightness / 100.0)
            self.brightness_bar.set_text(f"{brightness}%")

        # Get hardware info
        backlight_info = self.status_monitor.get_backlight_info()
        if backlight_info:
            percent, device = backlight_info
            hw_text = f"Backlight Device: {device}\nCurrent Brightness: {percent}%"
        else:
            hw_text = "No backlight device detected"

        self.hardware_label.set_text(hw_text)

        return True  # Continue timer

    def on_save_clicked(self, button):
        """Save configuration"""
        # Get values from UI
        self.config['enable_camera'] = self.camera_check.get_active()
        self.config['smoothing_factor'] = self.smoothing_scale.get_value()
        self.config['update_interval'] = self.interval_scale.get_value()
        self.config['min_brightness'] = int(self.min_brightness_scale.get_value())
        self.config['max_brightness'] = int(self.max_brightness_scale.get_value())

        # Get GUI settings
        self.gui_config['show_system_tray'] = self.tray_check.get_active()

        # Save both configs
        service_saved = ConfigManager.save_config(self.config)
        gui_saved = ConfigManager.save_gui_config(self.gui_config)

        if service_saved and gui_saved:
            # Try to reload the running service
            reload_success = False
            if self.service_control.is_running():
                reload_success = self.service_control.reload()

            dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Settings Saved"
            )

            if reload_success:
                dialog.format_secondary_text(
                    "Configuration has been saved and applied.\n"
                    "The service reloaded settings successfully."
                )
            elif self.service_control.is_running():
                dialog.format_secondary_text(
                    "Configuration has been saved.\n"
                    "Note: Failed to reload service. You may need to restart it manually."
                )
            else:
                dialog.format_secondary_text(
                    "Configuration has been saved.\n"
                    "Start the service to apply the changes."
                )

            dialog.run()
            dialog.destroy()
        else:
            dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Error Saving Settings"
            )
            if not service_saved and not gui_saved:
                msg = "Failed to save configuration files."
            elif not service_saved:
                msg = "Failed to save service configuration."
            else:
                msg = "Failed to save GUI configuration."
            dialog.format_secondary_text(msg)
            dialog.run()
            dialog.destroy()

    def ensure_tray_running(self):
        """Ensure system tray icon is running"""
        # Check if tray is already running
        try:
            result = subprocess.run(
                ['pgrep', '-f', 'ambient-brightness-gui --tray'],
                capture_output=True,
                timeout=2
            )
            if result.returncode == 0:
                return  # Already running
        except:
            pass

        # Start the tray icon
        try:
            subprocess.Popen(
                [sys.executable, __file__, '--tray'],
                start_new_session=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
        except Exception as e:
            print(f"Could not start tray icon: {e}")

    def on_start_clicked(self, button):
        """Start service"""
        if self.service_control.start():
            self.show_message("Service started successfully")
            # Auto-start tray icon when service is started
            self.ensure_tray_running()
        else:
            self.show_error("Failed to start service")
        self.update_status()

    def on_stop_clicked(self, button):
        """Stop service"""
        if self.service_control.stop():
            self.show_message("Service stopped successfully")
        else:
            self.show_error("Failed to stop service")
        self.update_status()

    def on_restart_clicked(self, button):
        """Restart service"""
        if self.service_control.restart():
            self.show_message("Service restarted successfully")
        else:
            self.show_error("Failed to restart service")
        self.update_status()

    def on_enable_toggled(self, button):
        """Toggle service enable at boot"""
        if button.get_active():
            if not self.service_control.enable():
                self.show_error("Failed to enable service")
                button.set_active(False)
            else:
                # Auto-start tray icon when enabling auto-start
                self.ensure_tray_running()
        else:
            if not self.service_control.disable():
                self.show_error("Failed to disable service")
                button.set_active(True)

    def on_refresh_logs_clicked(self, button):
        """Refresh service logs"""
        try:
            if self.service_control.use_systemd:
                result = subprocess.run(
                    ['journalctl', '--user', '-u', 'ambient-brightness', '-n', '100', '--no-pager'],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                log_text = result.stdout
            else:
                # Read from log file
                if LOG_FILE.exists():
                    lines = LOG_FILE.read_text().splitlines()
                    log_text = '\n'.join(lines[-100:])  # Last 100 lines
                else:
                    log_text = "No log file found. Start the service to generate logs."

            buffer = self.log_textview.get_buffer()
            buffer.set_text(log_text)

        except Exception as e:
            self.show_error(f"Failed to load logs: {e}")

    def show_message(self, text):
        """Show info message"""
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text=text
        )
        dialog.run()
        dialog.destroy()

    def show_error(self, text):
        """Show error message"""
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text=text
        )
        dialog.run()
        dialog.destroy()


class SystemTrayIndicator:
    """System tray indicator for quick access"""

    def __init__(self):
        self.indicator = AppIndicator3.Indicator.new(
            "ambient-brightness",
            "display-brightness-symbolic",
            AppIndicator3.IndicatorCategory.SYSTEM_SERVICES
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        self.indicator.set_menu(self.build_menu())

        self.service_control = ServiceControl()

        # Update status periodically
        GLib.timeout_add_seconds(5, self.update_status)
        self.update_status()

    def build_menu(self):
        """Build indicator menu"""
        menu = Gtk.Menu()

        # Status item
        self.status_item = Gtk.MenuItem(label="Status: Unknown")
        self.status_item.set_sensitive(False)
        menu.append(self.status_item)

        menu.append(Gtk.SeparatorMenuItem())

        # Open settings
        settings_item = Gtk.MenuItem(label="Settings...")
        settings_item.connect("activate", self.on_settings_clicked)
        menu.append(settings_item)

        # Quick start/stop
        self.toggle_item = Gtk.MenuItem(label="Start Service")
        self.toggle_item.connect("activate", self.on_toggle_clicked)
        menu.append(self.toggle_item)

        menu.append(Gtk.SeparatorMenuItem())

        # Quit
        quit_item = Gtk.MenuItem(label="Quit")
        quit_item.connect("activate", lambda x: Gtk.main_quit())
        menu.append(quit_item)

        menu.show_all()
        return menu

    def update_status(self):
        """Update status display"""
        is_running = self.service_control.is_running()

        if is_running:
            self.status_item.set_label("Status: Running")
            self.toggle_item.set_label("Stop Service")
        else:
            self.status_item.set_label("Status: Stopped")
            self.toggle_item.set_label("Start Service")

        return True

    def on_settings_clicked(self, item):
        """Open settings window"""
        window = SettingsWindow()
        # Don't connect destroy to main_quit - let the window close without killing the tray
        window.show_all()

    def on_toggle_clicked(self, item):
        """Toggle service on/off"""
        if self.service_control.is_running():
            self.service_control.stop()
        else:
            self.service_control.start()
        self.update_status()


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description='Ambient Brightness GUI')
    parser.add_argument('--tray', action='store_true', help='Run as system tray indicator')
    args = parser.parse_args()

    if args.tray:
        # Run as system tray
        indicator = SystemTrayIndicator()
        Gtk.main()
    else:
        # Run as settings window
        window = SettingsWindow()
        window.connect("destroy", Gtk.main_quit)
        window.show_all()
        Gtk.main()


if __name__ == '__main__':
    main()
